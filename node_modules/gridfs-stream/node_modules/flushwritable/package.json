{
  "name": "flushwritable",
  "version": "1.0.0",
  "description": "A Writable stream that flushes before emitting finish",
  "main": "lib/FlushWritable.js",
  "directories": {
    "test": "test"
  },
  "scripts": {
    "test": "mocha -R spec test"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/TomFrost/FlushWritable.git"
  },
  "keywords": [
    "stream",
    "streams",
    "writable",
    "flush",
    "transform",
    "wrapper"
  ],
  "author": {
    "name": "Tom Frost",
    "email": "tom@frosteddesign.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/TomFrost/FlushWritable/issues"
  },
  "homepage": "https://github.com/TomFrost/FlushWritable",
  "devDependencies": {
    "mocha": "^2.0.1",
    "should": "^4.3.0"
  },
  "readme": "# FlushWritable [![Build Status](https://travis-ci.org/TomFrost/FlushWritable.svg?branch=master)](https://travis-ci.org/TomFrost/FlushWritable)\nA Writable stream that flushes before emitting finish.\n\nSponsored by [Leadnomics](http://www.leadnomics.com).\n\n## What it is\nNode.js's Streams API is a fantastic tool, but has a nagging shortcoming:\nwhile the Transform stream implements a `_flush` method that is called before\nits final events are fired, the Writable stream does not.  So if you're\nbuffering rows to be INSERTed into a SQL table rather than slowly writing one\nat a time, or you're buffering bytes for a transfer to S3, there is no way of\nflushing those buffers to the target data store before the `finish` event is\nemitted.\n\n**FlushWritable is a drop-in replacement for stream.Writable** that implements\na `_flush` call that behaves exactly how Transform._flush does.  It's called\nwith a callback, waits for the callback to be called, and _then_ fires\n`finish` (or `error` if an error was passed).  No additional execution after\nthe `finish` event, no implementing nonstandard event types, no chaining a\nshell Transform stream before the Writable to hijack its `_flush` call.  And\nit's fully futureproof against the Node.js team actually adding a `_flush`\nmethod to the native stream.Writable in a later version of Node, so you don't\nhave to worry about your code breaking on upgrade.\n\n## How does it work?\nIt's pretty simple.  Writable is an EventEmitter.  FlushWritable extends\nWritable and overrides EventEmitter.emit in its own prototype, listening for a\nrequest that `finish` be emitted.  When that comes in, it blocks that event\nfrom emitting, and calls `_flush` if it's defined.\n\nThe callback it passes to `_flush` will trigger `finish` to actually be\nemitted.  If that callback is called with a truthy first argument, `error` is\nemitted instead.  All other events pass right through and are emitted as\nexpected.  If a future version of node adds a `Writable.prototype._flush`\nmethod, the whole thing short-circuits and native functionality takes over.\n\n## Installation\nIn your project folder, type:\n\n\tnpm install flushwritable --save\n\n## Usage\nJust extend FlushWritable instead of stream.Writable in your write stream, and\nfeel free to define a `_flush(cb)` function!\n\n```javascript\nvar FlushWritable = require('flushwritable'),\n    util = require('util');\n\nfunction MyWriteStream(opts) {\n    FlushWritable.call(this, opts);\n    this._buffer = [];\n}\nutil.inherits(MyWriteStream, FlushWritable);\n\nMyWriteStream.prototype._flush = function(cb) {\n\twriteBufferSomewhere(this._buffer, cb);\n};\n\nMyWriteStream.prototype._write = function(data, encoding, cb) {\n\tthis._buffer.push(data);\n\tcb();\n};\n```\n\n## License\nFlushWritable is distributed under the MIT license.\n\n## Credits\nFlushWritable was created by Tom Frost at Leadnomics in 2014.\n",
  "readmeFilename": "README.md",
  "_id": "flushwritable@1.0.0",
  "_shasum": "3e328d8fde412ad47e738e3be750b4d290043498",
  "_resolved": "https://registry.npmjs.org/flushwritable/-/flushwritable-1.0.0.tgz",
  "_from": "https://registry.npmjs.org/flushwritable/-/flushwritable-1.0.0.tgz"
}
